import ast
import os
from typing import Optional

from src.ast_parser import ASTParser


def create_or_update_class(target_folder: str, class_: ast.ClassDef):
    filename = f'{target_folder}/{_pascal_case_to_snake_case(class_.name)}.py'
    existing_module = _get_existing_module(filename)
    new_module = _build_updated_module(existing_module, class_)
    with open(filename, 'w') as target_file:
        target_file.write(ast.unparse(new_module))


def _get_existing_module(filename) -> Optional[ast.Module]:
    if os.path.exists(filename):
        with open(filename, 'r') as target_file:
            existing_source = target_file.read()
        return ast.parse(existing_source)
    return None


def _build_updated_module(existing_module: Optional[ast.Module], generated_class: ast.ClassDef) -> ast.Module:
    imports = ASTParser.get_or_create_manual_imports(existing_module)
    manual_code = ASTParser.get_or_create_manual_class_code(existing_module)

    new_module = ast.parse('"""Partially autogenerated - edit only inside manual sections"""\n'
                           'from . import db')

    def build_header():
        for import_ in imports:
            new_module.body.append(import_)

    def build_class():
        new_class = ASTParser.clone_class(generated_class)
        for manual_code_statement in manual_code:
            new_class.body.append(manual_code_statement)
        new_module.body.append(new_class)

    build_header()
    build_class()
    return new_module


def _pascal_case_to_snake_case(pascal_case_name: str) -> str:
    snake_case_name = ""
    for char in pascal_case_name:
        if char.isupper():
            snake_case_name += "_"
        snake_case_name += char.lower()
    return snake_case_name[1:]
